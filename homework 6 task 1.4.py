"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для четвертого скрипта
"""

''' Задача
Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен 
принимать данные (список списков) для формирования матрицы.
Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
Далее реализовать перегрузку метода __add__() для сложения двух объектов класса Matrix (двух матриц). Результатом 
сложения должна быть новая матрица.
Подсказка: сложение элементов матриц выполнять поэлементно. Первый элемент первой строки первой матрицы складываем с 
первым элементом первой строки второй матрицы и пр.
'''
from memory_profiler import memory_usage
import numpy as np


# Декоратор для профилирования памяти у методов классов
def memory_measur(func):
    def wrapper(*args, **kwargs):
        m1 = memory_usage()
        res = func(*args)
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        print(f"Выполнение заняло {mem_diff} Mib")
        return res

    return wrapper


# Базовая реализация
class Matrix:
    def __init__(self, matrix_mass):
        self.matrix = matrix_mass

    def __str__(self):
        res = ""
        for line in self.matrix:
            for element in line:
                res += f"{element} "
            else:
                res = res[:-1]
                res += "\n"
        return res[:-1]

    @memory_measur
    def __add__(self, mat):
        matrix_res = []
        for num_line, line in enumerate(self.matrix):
            matrix_res.append(line[:])
            for num_element, element in enumerate(line):
                try:
                    matrix_res[num_line][num_element] += mat.matrix[num_line][num_element]
                except IndexError:
                    if num_element == 0:
                        matrix_res[num_line] = []
                        break
                    else:
                        matrix_res[num_line][num_element] = None

        for line in reversed(matrix_res):
            if not line:
                matrix_res.pop()
            else:
                for element in reversed(line):
                    if not element:
                        line.pop()
        return Matrix(matrix_res)


mat1 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
mat2 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
mat3 = mat2 + mat1


# Оптимизированная реализация
@memory_measur
def sum_matrix(A, B):
    return A + B


A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
B = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])

print(mat3, "\n")
print(sum_matrix(A, B))

''' Результаты 
Выполнение заняло 0.01171875 Mib
2 4 6
8 10 12
14 16 18
20 22 24 
Выполнение заняло 0.00390625 Mib
[[ 2  4  6]
 [ 8 10 12]
 [14 16 18]
 [20 22 24]]
'''
'''Анализ измененного кода
Использовал в решении модуль numpy, для работы с матрицами, что позволило сократить затраты памяти
'''